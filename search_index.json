[["index.html", "Bioinformatics tools and pipelines using R and CWL Preface 0.1 R package installation 0.2 System requirements 0.3 Docker 0.4 Structure of the book 0.5 R session information", " Bioinformatics tools and pipelines using R and CWL Qiang Hu Qian Liu 2020-11-13 Preface This short book introduces the R packages, Rcwl and RcwlPipelines, to improve the way of building, managing and running Bioinformatics tools and pipelines. The Rcwl package is built on top of the Common Workflow Language (CWL), and provides a simple and user-friendly way to wrap command line tools into data analysis pipelines in R. The RcwlPipelines package is a collection of Bioinformatics tools and pipelines based on Rcwl. 0.1 R package installation The Rcwl and RcwlPipelines packages can be installed from Bioconductor or Github: BiocManager::install(c(&quot;Rcwl&quot;, &quot;RcwlPipelines&quot;)) # or the development version BiocManager::install(c(&quot;hubentu/Rcwl&quot;, &quot;hubentu/RcwlPipelines&quot;)) To load the packages into R session: library(Rcwl) library(RcwlPipelines) 0.2 System requirements In addition to the R packages, the following tools are required to be installed to run the examples in this book. python (&gt;= 2.7) cwltool (&gt;= 1.0.2018) nodejs The cwltool is the reference implementation of the Common Workflow Language, which is used to run the CWL scripts. The nodejs is required when the CWL scripts use JavaScript. You can find instructions to install these tools here: https://github.com/common-workflow-language/cwltool#install https://nodejs.org 0.3 Docker The Docker container simplifies software installation and management, especially for bioinformatics tools/pipelines requiring different runtime environments and library dependencies. A CWL runner can perform this work automatically by pulling the Docker containers and mounting the paths of input files. The Docker requirement is optional, as CWL scripts can also be run locally with all the dependencies pre-installed. 0.4 Structure of the book Introduction Components Build CWL workflows Run approaches Case study 0.5 R session information The R session information for compiling this mannual is shown below: sessionInfo() ## R version 4.0.2 (2020-06-22) ## Platform: x86_64-apple-darwin19.3.0 (64-bit) ## Running under: macOS Catalina 10.15.6 ## ## Matrix products: default ## BLAS/LAPACK: /Users/qi31566/homebrew/Cellar/openblas/0.3.10_1/lib/libopenblasp-r0.3.10.dylib ## ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ## ## attached base packages: ## [1] parallel stats4 stats graphics grDevices utils datasets ## [8] methods base ## ## other attached packages: ## [1] RcwlPipelines_1.6.0 BiocFileCache_1.14.0 dbplyr_2.0.0 ## [4] Rcwl_1.6.0 S4Vectors_0.28.0 BiocGenerics_0.36.0 ## [7] yaml_2.2.1 bookdown_0.21 ## ## loaded via a namespace (and not attached): ## [1] Rcpp_1.0.5 tidyr_1.1.2 prettyunits_1.1.1 ## [4] visNetwork_2.0.9 assertthat_0.2.1 digest_0.6.27 ## [7] mime_0.9 R6_2.5.0 backports_1.2.0 ## [10] RSQLite_2.2.1 evaluate_0.14 httr_1.4.2 ## [13] pillar_1.4.6 rlang_0.4.8 progress_1.2.2 ## [16] curl_4.3 rstudioapi_0.12 data.table_1.13.2 ## [19] blob_1.2.1 R.utils_2.10.1 R.oo_1.24.0 ## [22] checkmate_2.0.0 rmarkdown_2.5 DiagrammeR_1.0.6.1 ## [25] BiocParallel_1.24.1 stringr_1.4.0 htmlwidgets_1.5.2 ## [28] igraph_1.2.6 bit_4.0.4 shiny_1.5.0 ## [31] compiler_4.0.2 httpuv_1.5.4 xfun_0.19 ## [34] pkgconfig_2.0.3 htmltools_0.5.0 tidyselect_1.1.0 ## [37] tibble_3.0.4 batchtools_0.9.14 codetools_0.2-18 ## [40] crayon_1.3.4 dplyr_1.0.2 withr_2.3.0 ## [43] later_1.1.0.1 R.methodsS3_1.8.1 rappdirs_0.3.1 ## [46] jsonlite_1.7.1 xtable_1.8-4 lifecycle_0.2.0 ## [49] DBI_1.1.0 magrittr_1.5 stringi_1.5.3 ## [52] debugme_1.1.0 promises_1.1.1 ellipsis_0.3.1 ## [55] brew_1.0-6 generics_0.1.0 vctrs_0.3.4 ## [58] RColorBrewer_1.1-2 tools_4.0.2 bit64_4.0.5 ## [61] glue_1.4.2 purrr_0.3.4 hms_0.5.3 ## [64] fastmap_1.0.1 base64url_1.4 memoise_1.1.0 ## [67] knitr_1.30 "],["intro.html", "Chapter 1 Introduction 1.1 Common Workflow Language 1.2 First example 1.3 Test run", " Chapter 1 Introduction 1.1 Common Workflow Language “The Common Workflow Language (CWL) is a specification for describing analysis workflows and tools in a way that makes them portable and scalable across a variety of software and hardware environments, from workstations to cluster, cloud, and high performance computing (HPC) environments.” https://www.commonwl.org/ To wrap tool and workflow parameters in a standard format Capable of invoking tools from Docker containers Widely used… 1.2 First example The main class and constructor function is cwlParam, which wraps a command line tool and its parameters in a cwlParam object. Let’s start with a simple example, echo hello world. First, we load the package and define the input parameter for “echo”, a string without a prefix. Just an id option required here: input1 &lt;- InputParam(id = &quot;sth&quot;) Second, we create a cwlParam object with baseCommand for the command to execute and InputParamList for the input parameters. echo &lt;- cwlParam(baseCommand = &quot;echo&quot;, inputs = InputParamList(input1)) Now we have a command object to run. Let’s send a string “Hello World!” to the object. Without defining the outputs, it will stream standard output to a temporary file by default. echo$sth &lt;- &quot;Hello World!&quot; echo ## class: cwlParam ## cwlClass: CommandLineTool ## cwlVersion: v1.0 ## baseCommand: echo ## inputs: ## sth (string): Hello World! ## outputs: ## output: ## type: stdout 1.3 Test run The function runCWL is used to run the CWL object by invoking the python tool cwltool. The return will be a list including the command executed, temporary output and logs. The output directory is the current folder by default, but it can be changed by setting outdir option. All standard out and standard error streams can also be printed by setting stderr = \"\". r1 &lt;- runCWL(echo, outdir = tempdir()) ## [1;30mINFO[0m Final process status is success r1 ## List of length 3 ## names(3): command output logs Here we can check the output to ensure the code did what we expected. r1$output ## [1] &quot;/var/folders/7t/9l4kkf_j2sqbpn321y9g5558z96ck_/T/RtmpEc6LEy/bd3f3585e8b00aa1bc301ad65636d535784571a8&quot; readLines(r1$output) ## [1] &quot;Hello World!&quot; The executed command was returned in the result list. It shows the command that we have defined to execute. r1$command ## [1] &quot;\\033[1;30mINFO\\033[0m [job filebb6748f0e277.cwl] /private/tmp/docker_tmpj2h6v1bk$ echo \\\\&quot; ## [2] &quot; &#39;Hello World!&#39; &gt; /private/tmp/docker_tmpj2h6v1bk/bd3f3585e8b00aa1bc301ad65636d535784571a8&quot; The log shows the details of how the cwltool works with CWL scripts. r1$log ## [1] &quot;\\033[1;30mINFO\\033[0m /Users/qi31566/Library/Python/3.7/bin/cwltool 3.0.20200324120055&quot; ## [2] &quot;\\033[1;30mINFO\\033[0m Resolved &#39;/var/folders/7t/9l4kkf_j2sqbpn321y9g5558z96ck_/T//RtmpEc6LEy/filebb6748f0e277.cwl&#39; to &#39;file:///var/folders/7t/9l4kkf_j2sqbpn321y9g5558z96ck_/T/RtmpEc6LEy/filebb6748f0e277.cwl&#39;&quot; ## [3] &quot;\\033[1;30mINFO\\033[0m [job filebb6748f0e277.cwl] /private/tmp/docker_tmpj2h6v1bk$ echo \\\\&quot; ## [4] &quot; &#39;Hello World!&#39; &gt; /private/tmp/docker_tmpj2h6v1bk/bd3f3585e8b00aa1bc301ad65636d535784571a8&quot; ## [5] &quot;\\033[1;30mINFO\\033[0m [job filebb6748f0e277.cwl] completed success&quot; ## [6] &quot;{&quot; ## [7] &quot; \\&quot;output\\&quot;: {&quot; ## [8] &quot; \\&quot;location\\&quot;: \\&quot;file:///var/folders/7t/9l4kkf_j2sqbpn321y9g5558z96ck_/T/RtmpEc6LEy/bd3f3585e8b00aa1bc301ad65636d535784571a8\\&quot;,&quot; ## [9] &quot; \\&quot;basename\\&quot;: \\&quot;bd3f3585e8b00aa1bc301ad65636d535784571a8\\&quot;,&quot; ## [10] &quot; \\&quot;class\\&quot;: \\&quot;File\\&quot;,&quot; ## [11] &quot; \\&quot;checksum\\&quot;: \\&quot;sha1$a0b65939670bc2c010f4d5d6a0b3e4e4590fb92b\\&quot;,&quot; ## [12] &quot; \\&quot;size\\&quot;: 13,&quot; ## [13] &quot; \\&quot;path\\&quot;: \\&quot;/var/folders/7t/9l4kkf_j2sqbpn321y9g5558z96ck_/T/RtmpEc6LEy/bd3f3585e8b00aa1bc301ad65636d535784571a8\\&quot;&quot; ## [14] &quot; }&quot; ## [15] &quot;}&quot; ## [16] &quot;\\033[1;30mINFO\\033[0m Final process status is success&quot; The runCWL generated two scripts with the default tempfile prefix, the tool wrapper CWL file and the input YML file. The cwltool parses the two scripts and translates them into the command shown before. The output is not defined in the cwlParam object, so the command output was returned to stdout by default. "],["components.html", "Chapter 2 Components 2.1 Input Parameters 2.2 Output Parameters", " Chapter 2 Components 2.1 Input Parameters 2.1.1 Essential Input parameters For the input parameters, we usually need to define three options, id, type, and prefix. The type can be string, int, long, float, double, and so on. More detail can be found at: https://www.commonwl.org/v1.0/CommandLineTool.html#CWLType. A InputParam constructor is used to define a list of input objects for the command tool, such as “prefix” for the parameter flags and “position” for the paramter orders. More descriptions are available in the CWL specification https://www.commonwl.org/v1.0/CommandLineTool.html#CommandLineBinding. Here is an example from the CWL user guide(http://www.commonwl.org/user_guide/03-input/). We defined the echo with different type of input parameters by InputParam, and the stdout option can be used to caputre the standard output stream into a file: e1 &lt;- InputParam(id = &quot;flag&quot;, type = &quot;boolean&quot;, prefix = &quot;-f&quot;) e2 &lt;- InputParam(id = &quot;string&quot;, type = &quot;string&quot;, prefix = &quot;-s&quot;) e3 &lt;- InputParam(id = &quot;int&quot;, type = &quot;int&quot;, prefix = &quot;-i&quot;) e4 &lt;- InputParam(id = &quot;file&quot;, type = &quot;File&quot;, prefix = &quot;--file=&quot;, separate = FALSE) echoA &lt;- cwlParam(baseCommand = &quot;echo&quot;, inputs = InputParamList(e1, e2, e3, e4), stdout = &quot;output.txt&quot;) Then we give it a try by setting values for the inputs: echoA$flag &lt;- TRUE echoA$string &lt;- &quot;Hello&quot; echoA$int &lt;- 1 tmpfile &lt;- tempfile() write(&quot;World&quot;, tmpfile) echoA$file &lt;- tmpfile r2 &lt;- runCWL(echoA, outdir = tempdir()) ## [1;30mINFO[0m Final process status is success r2$command ## [1] &quot;\\033[1;30mINFO\\033[0m [job filebb67629e8bd4.cwl] /private/tmp/docker_tmpaw__qze1$ echo \\\\&quot; ## [2] &quot; --file=/private/var/folders/7t/9l4kkf_j2sqbpn321y9g5558z96ck_/T/tmpr093pq8p/stgd1230c8b-6e34-48fa-b574-6b9b8b910da3/filebb677fccdc78 \\\\&quot; ## [3] &quot; -f \\\\&quot; ## [4] &quot; -i \\\\&quot; ## [5] &quot; 1 \\\\&quot; ## [6] &quot; -s \\\\&quot; ## [7] &quot; Hello &gt; /private/tmp/docker_tmpaw__qze1/output.txt&quot; 2.1.2 Array Inputs Taking a similar example to the CWL user guide described above, we can define three different type of array as inputs: a1 &lt;- InputParam(id = &quot;A&quot;, type = &quot;string[]&quot;, prefix = &quot;-A&quot;) a2 &lt;- InputParam(id = &quot;B&quot;, type = InputArrayParam(items = &quot;string&quot;, prefix=&quot;-B=&quot;, separate = FALSE)) a3 &lt;- InputParam(id = &quot;C&quot;, type = &quot;string[]&quot;, prefix = &quot;-C=&quot;, itemSeparator = &quot;,&quot;, separate = FALSE) echoB &lt;- cwlParam(baseCommand = &quot;echo&quot;, inputs = InputParamList(a1, a2, a3)) We then set values for the three inputs: echoB$A &lt;- letters[1:3] echoB$B &lt;- letters[4:6] echoB$C &lt;- letters[7:9] echoB ## class: cwlParam ## cwlClass: CommandLineTool ## cwlVersion: v1.0 ## baseCommand: echo ## inputs: ## A (string[]): -A a b c ## B: ## type: array ## prefix: -B= d e f ## C (string[]): -C= g h i ## outputs: ## output: ## type: stdout Now we can check whether the command behaves as we expected: r3 &lt;- runCWL(echoB, outdir = tempdir()) ## [1;30mINFO[0m Final process status is success r3$command ## [1] &quot;\\033[1;30mINFO\\033[0m [job filebb672eb035b5.cwl] /private/tmp/docker_tmp_1zei12i$ echo \\\\&quot; ## [2] &quot; -A \\\\&quot; ## [3] &quot; a \\\\&quot; ## [4] &quot; b \\\\&quot; ## [5] &quot; c \\\\&quot; ## [6] &quot; -B=d \\\\&quot; ## [7] &quot; -B=e \\\\&quot; ## [8] &quot; -B=f \\\\&quot; ## [9] &quot; -C=g,h,i &gt; /private/tmp/docker_tmp_1zei12i/442b16f999dace58bb07974cd763c18a711c7707&quot; 2.2 Output Parameters 2.2.1 Capturing Output The outputs, similar to the inputs, is a list of output parameters. Three options, id, type and glob, can be defined. The glob option is used to define a pattern to find files relative to the output directory. Here is an example to unzip a compressed gz file. First, we generate a compressed R script file: zzfil &lt;- file.path(tempdir(), &quot;sample.R.gz&quot;) zz &lt;- gzfile(zzfil, &quot;w&quot;) cat(&quot;sample(1:10, 5)&quot;, file = zz, sep = &quot;\\n&quot;) close(zz) We then define a cwlParam object to use “gzip” to uncompress an input file: ofile &lt;- &quot;sample.R&quot; z1 &lt;- InputParam(id = &quot;uncomp&quot;, type = &quot;boolean&quot;, prefix = &quot;-d&quot;) z2 &lt;- InputParam(id = &quot;out&quot;, type = &quot;boolean&quot;, prefix = &quot;-c&quot;) z3 &lt;- InputParam(id = &quot;zfile&quot;, type = &quot;File&quot;) o1 &lt;- OutputParam(id = &quot;rfile&quot;, type = &quot;File&quot;, glob = ofile) gz &lt;- cwlParam(baseCommand = &quot;gzip&quot;, inputs = InputParamList(z1, z2, z3), outputs = OutputParamList(o1), stdout = ofile) Now the gz object can be used to uncompress the previously generated compressed file: gz$uncomp &lt;- TRUE gz$out &lt;- TRUE gz$zfile &lt;- zzfil r4 &lt;- runCWL(gz, outdir = tempdir()) ## [1;30mINFO[0m Final process status is success r4$output ## [1] &quot;/var/folders/7t/9l4kkf_j2sqbpn321y9g5558z96ck_/T/RtmpEc6LEy/sample.R&quot; Or we can use arguments to set some default parameters: z1 &lt;- InputParam(id = &quot;zfile&quot;, type = &quot;File&quot;) o1 &lt;- OutputParam(id = &quot;rfile&quot;, type = &quot;File&quot;, glob = ofile) Gz &lt;- cwlParam(baseCommand = &quot;gzip&quot;, arguments = list(&quot;-d&quot;, &quot;-c&quot;), inputs = InputParamList(z1), outputs = OutputParamList(o1), stdout = ofile) Gz ## class: cwlParam ## cwlClass: CommandLineTool ## cwlVersion: v1.0 ## baseCommand: gzip ## arguments: -d -c ## inputs: ## zfile (File): ## outputs: ## rfile: ## type: File ## outputBinding: ## glob: sample.R ## stdout: sample.R Gz$zfile &lt;- zzfil r4a &lt;- runCWL(Gz, outdir = tempdir()) ## [1;30mINFO[0m Final process status is success To make it for general usage, we can define a pattern with javascript to glob the output, which requires node to be installed in your system PATH: pfile &lt;- &quot;$(inputs.zfile.path.split(&#39;/&#39;).slice(-1)[0].split(&#39;.&#39;).slice(0,-1).join(&#39;.&#39;))&quot; Or we can directly use the CWL built in file property, nameroot: pfile &lt;- &quot;$(inputs.zfile.nameroot)&quot; o2 &lt;- OutputParam(id = &quot;rfile&quot;, type = &quot;File&quot;, glob = pfile) req1 &lt;- list(class = &quot;InlineJavascriptRequirement&quot;) GZ &lt;- cwlParam(baseCommand = c(&quot;gzip&quot;, &quot;-d&quot;, &quot;-c&quot;), requirements = list(), ## assign list(req1) if node installed. inputs = InputParamList(z1), outputs = OutputParamList(o2), stdout = pfile) GZ$zfile &lt;- zzfil r4b &lt;- runCWL(GZ, outdir = tempdir()) ## [1;30mINFO[0m Final process status is success 2.2.2 Array Outputs We can also capture multiple output files with the glob pattern: a &lt;- InputParam(id = &quot;a&quot;, type = InputArrayParam(items = &quot;string&quot;)) b &lt;- OutputParam(id = &quot;b&quot;, type = OutputArrayParam(items = &quot;File&quot;), glob = &quot;*.txt&quot;) touch &lt;- cwlParam(baseCommand = &quot;touch&quot;, inputs = InputParamList(a), outputs = OutputParamList(b)) touch$a &lt;- c(&quot;a.txt&quot;, &quot;b.gz&quot;, &quot;c.txt&quot;) r5 &lt;- runCWL(touch, outdir = tempdir()) ## [1;30mINFO[0m Final process status is success r5$output ## [1] &quot;/var/folders/7t/9l4kkf_j2sqbpn321y9g5558z96ck_/T/RtmpEc6LEy/a.txt&quot; ## [2] &quot;/var/folders/7t/9l4kkf_j2sqbpn321y9g5558z96ck_/T/RtmpEc6LEy/c.txt&quot; 2.2.3 Standard output Usually, the stdout option is a string or an expression of output file name from the command tool. The command’s standard output stream will be captured into a file written to the designated output directory. When the stdout field is defined, an output parameter with the type of “stdout” should be also assigned with no “outputBinding” set. An example for command tool “cat” is defined with stdout field in the output, with the name passed from the input parameter “p2”: ## define Cat p1 &lt;- InputParam(id = &quot;infiles&quot;, type = &quot;File[]&quot;) p2 &lt;- InputParam(id = &quot;outfile&quot;, type = &quot;string&quot;, default = &quot;catout.txt&quot;, position = -1) Cat &lt;- cwlParam(baseCommand = &quot;cat&quot;, inputs = InputParamList(p1, p2), stdout = &quot;$(inputs.outfile)&quot;) ## assign inputs afile &lt;- file.path(tempdir(), &quot;a.txt&quot;) bfile &lt;- file.path(tempdir(), &quot;b.txt&quot;) write(&quot;a&quot;, afile) write(&quot;b&quot;, bfile) Cat$infiles &lt;- list(afile, bfile) ## run r6 &lt;- runCWL(Cat, outdir = tempdir()) ## [1;30mINFO[0m Final process status is success r6$command ## [1] &quot;\\033[1;30mINFO\\033[0m [job filebb677b0f841.cwl] /private/tmp/docker_tmpzi3wag6g$ cat \\\\&quot; ## [2] &quot; /private/var/folders/7t/9l4kkf_j2sqbpn321y9g5558z96ck_/T/tmpg4xvk88k/stga315fc45-6aea-4884-a44d-ac49937ef82c/a.txt \\\\&quot; ## [3] &quot; /private/var/folders/7t/9l4kkf_j2sqbpn321y9g5558z96ck_/T/tmpg4xvk88k/stg9f426cea-f116-4dc3-be02-924bf46a8b85/b.txt &gt; /private/tmp/docker_tmpzi3wag6g/catout.txt&quot; In this example, we used the parameter “p2” to pass the name to the standard output. In the InputParam of “p2”, the position is assigned to a negative value (-1), which means the parameters will not be used in the command and only uses for passing variable. To write the “Cat” tool to a CWL file, the “inputBinding” field will be skipped for this parameter. "],["writing-pipeline.html", "Chapter 3 Writing Pipeline 3.1 Scattering pipeline 3.2 Pipeline plot", " Chapter 3 Writing Pipeline We can connect multiple tools into a pipeline. Here is an example to uncompress an R script and execute it with Rscript. We first define a simple Rscript tool without using docker: d1 &lt;- InputParam(id = &quot;rfile&quot;, type = &quot;File&quot;) Rs &lt;- cwlParam(baseCommand = &quot;Rscript&quot;, inputs = InputParamList(d1)) Rs ## class: cwlParam ## cwlClass: CommandLineTool ## cwlVersion: v1.0 ## baseCommand: Rscript ## inputs: ## rfile (File): ## outputs: ## output: ## type: stdout Here is the test run: Rs$rfile &lt;- r4$output tres &lt;- runCWL(Rs, outdir = tempdir()) ## [1;30mINFO[0m Final process status is success readLines(tres$output) ## [1] &quot;[1] 9 1 4 7 5&quot; The pipeline includes two steps, decompressed by GZ and compiled by Rs. The input file is a compressed file and the output file would be the output Rout from Rs. First we need to define the direct inputs and outputs from GZ and Rs, respectively: i1 &lt;- InputParam(id = &quot;cwl_zfile&quot;, type = &quot;File&quot;) o1 &lt;- OutputParam(id = &quot;cwl_cout&quot;, type = &quot;File&quot;, outputSource = &quot;Compile/output&quot;) For the input “cwl_zifle”, it refers to the GZ input zfile. The output “cwl_cout” will be the outcome of Rs output Rout. The cwlStepParam is used to define inputs and outputs, and the Step function is used to define the two steps. The run option refers to the corresponding cwlParam object and the In option should be linked to the input parameters defined by cwlStepParam. At the end, we use + to connect all steps: cwl &lt;- cwlStepParam(inputs = InputParamList(i1), outputs = OutputParamList(o1)) s1 &lt;- Step(id = &quot;Uncomp&quot;, run = GZ, In = list(zfile = &quot;cwl_zfile&quot;)) s2 &lt;- Step(id = &quot;Compile&quot;, run = Rs, In = list(rfile = &quot;Uncomp/rfile&quot;)) cwl &lt;- cwl + s1 + s2 cwl ## class: cwlStepParam ## cwlClass: Workflow ## cwlVersion: v1.0 ## inputs: ## cwl_zfile (File): ## outputs: ## cwl_cout: ## type: File ## outputSource: Compile/output ## steps: ## Uncomp: ## run: Uncomp.cwl ## zfile: cwl_zfile ## out: rfile ## Compile: ## run: Compile.cwl ## rfile: Uncomp/rfile ## out: output Let’s run the pipeline: cwl$cwl_zfile &lt;- zzfil r7 &lt;- runCWL(cwl, outdir = tempdir()) ## [1;30mINFO[0m Final process status is success readLines(r7$output) ## [1] &quot;[1] 6 5 9 3 8&quot; 3.1 Scattering pipeline The scattering feature can specify the associated workflow steps or subworkflows to execute separately over a list of input elements. To use this feature, ScatterFeatureRequirement must be specified in the workflow requirement. Different scatter methods can be used in the associated steps to decompose the input into a discrete set of jobs. More details can be found at: https://www.commonwl.org/v1.0/Workflow.html#WorkflowStep. Here is an example to execute multiple R scripts. First, we need to set the input and output types to be an array of “File”, and add the requirments. In the “Compile” step, the scattering input is required to be set with the scatter option: i2 &lt;- InputParam(id = &quot;cwl_rfiles&quot;, type = &quot;File[]&quot;) o2 &lt;- OutputParam(id = &quot;cwl_couts&quot;, type = &quot;File[]&quot;, outputSource = &quot;Compile/output&quot;) req1 &lt;- list(class = &quot;ScatterFeatureRequirement&quot;) cwl2 &lt;- cwlStepParam(requirements = list(req1), inputs = InputParamList(i2), outputs = OutputParamList(o2)) s1 &lt;- Step(id = &quot;Compile&quot;, run = Rs, In = list(rfile = &quot;cwl_rfiles&quot;), scatter = &quot;rfile&quot;) cwl2 &lt;- cwl2 + s1 cwl2 ## class: cwlStepParam ## cwlClass: Workflow ## cwlVersion: v1.0 ## requirements: ## - class: ScatterFeatureRequirement ## inputs: ## cwl_rfiles (File[]): ## outputs: ## cwl_couts: ## type: File[] ## outputSource: Compile/output ## steps: ## Compile: ## run: Compile.cwl ## rfile: cwl_rfiles ## out: output ## scatter: rfile Now multiple R scripts can be assigned to the workflow inputs and executed: cwl2$cwl_rfiles &lt;- c(r4b$output, r4b$output) r8 &lt;- runCWL(cwl2, outdir = tempdir()) ## [1;30mINFO[0m Final process status is success r8$output ## [1] &quot;/var/folders/7t/9l4kkf_j2sqbpn321y9g5558z96ck_/T/RtmpEc6LEy/656dd485280e6d7bb1d77f50ebfb751a8bdcf0b3&quot; ## [2] &quot;/var/folders/7t/9l4kkf_j2sqbpn321y9g5558z96ck_/T/RtmpEc6LEy/656dd485280e6d7bb1d77f50ebfb751a8bdcf0b3_2&quot; 3.2 Pipeline plot The function plotCWL can be used to visualize the relationship of inputs, outputs and the components for a tool or pipeline: plotCWL(cwl) "],["run-approaches.html", "Chapter 4 Run approaches 4.1 Running Tools in Docker 4.2 Running Tools in Cluster server 4.3 Web Application", " Chapter 4 Run approaches 4.1 Running Tools in Docker The CWL can work with docker to simplify your software management and communicate files between host and container. The docker container can be defined by the hints or requirements option: d1 &lt;- InputParam(id = &quot;rfile&quot;, type = &quot;File&quot;) req1 &lt;- list(class = &quot;DockerRequirement&quot;, dockerPull = &quot;r-base&quot;) doc &lt;- cwlParam(baseCommand = &quot;Rscript&quot;, inputs = InputParamList(d1), stdout = &quot;output.txt&quot;, hints = list(req1)) doc$rfile &lt;- r4$output r6 &lt;- runCWL(doc) The tools defined with docker requirements can also be run locally by disabling the docker option. In case your Rscript depends some local libraries to run, an option from cwltools, “–preserve-entire-environment”, can be used to pass all environment variables. r6a &lt;- runCWL(doc, docker = FALSE, outdir = tempdir(), cwlArgs = &quot;--preserve-entire-environment&quot;) ## [1;30mINFO[0m Final process status is success 4.2 Running Tools in Cluster server The CWL can also work in high performance clusters with batch-queuing system, such as SGE, PBS, SLURM and so on, using the Bioconductor package BiocParallel. Here is an example to submit jobs with “Multiicore” and “SGE”, seperately: library(BiocParallel) sth.list &lt;- as.list(LETTERS) names(sth.list) &lt;- LETTERS ## submit with mutlicore result1 &lt;- runCWLBatch(cwl = echo, outdir = tempdir(), inputList = list(sth = sth.list), BPPARAM = MulticoreParam(26)) ## submit with SGE result2 &lt;- runCWLBatch(cwl = echo, outdir = tempdir(), inputList = list(sth = sth.list), BPPARAM = BatchtoolsParam(workers = 26, cluster = &quot;sge&quot;, resources = list(queue = &quot;all.q&quot;))) A more detailed example can be found (https://hubentu.github.io/others/Rcwl_RNASeq.html). 4.3 Web Application 4.3.1 cwlParam example Here we build a tool with different types of input parameters: e1 &lt;- InputParam(id = &quot;flag&quot;, type = &quot;boolean&quot;, prefix = &quot;-f&quot;, doc = &quot;boolean flag&quot;) e2 &lt;- InputParam(id = &quot;string&quot;, type = &quot;string&quot;, prefix = &quot;-s&quot;) e3 &lt;- InputParam(id = &quot;option&quot;, type = &quot;string&quot;, prefix = &quot;-o&quot;) e4 &lt;- InputParam(id = &quot;int&quot;, type = &quot;int&quot;, prefix = &quot;-i&quot;, default = 123) e5 &lt;- InputParam(id = &quot;file&quot;, type = &quot;File&quot;, prefix = &quot;--file=&quot;, separate = FALSE) e6 &lt;- InputParam(id = &quot;array&quot;, type = &quot;string[]&quot;, prefix = &quot;-A&quot;, doc = &quot;separated by comma&quot;) mulEcho &lt;- cwlParam(baseCommand = &quot;echo&quot;, id = &quot;mulEcho&quot;, label = &quot;Test parameter types&quot;, inputs = InputParamList(e1, e2, e3, e4, e5, e6), stdout = &quot;output.txt&quot;) mulEcho ## class: cwlParam ## cwlClass: CommandLineTool ## cwlVersion: v1.0 ## baseCommand: echo ## inputs: ## flag (boolean): -f ## string (string): -s ## option (string): -o ## int (int): -i 123 ## file (File): --file= ## array (string[]): -A ## outputs: ## output: ## type: stdout ## stdout: output.txt 4.3.2 cwlParam to Shiny App Some input parameters can be predefined in a list, which will be converted to selected options in the webapp. An upload parameter can be used to generate an upload interface for the file type option. If FALSE is set for upload, the upload field will be text input (file path) instead of file input. inputList &lt;- list(option = c(&quot;option1&quot;, &quot;option2&quot;)) app &lt;- cwlShiny(mulEcho, inputList, upload = TRUE) runApp(app) shinyApp "],["references.html", "References", " References "]]
