
# RNA-Seq alignment and quantification
```{r}
library(RcwlPipelines)
library(BiocParallel)
library(fs)
library(dplyr)
library(conflicted)
## always use select from dplyr
conflict_prefer("select", "dplyr", quiet = TRUE)
```

## bulk mRNA
The `rnaseq_Sf` pipeline was built with reads quality summary, `STAR` alignment,
quantification by `featureCounts` and `RSeQC` quality control. Here
are the inputs:

```{r}
inputs(rnaseq_Sf)
```

The pipeline includes 6 steps:

* `fastqc`: To run quality summary for raw fastqs with `fastqc`.
* `STAR`: To align fastqs with `STAR`.
* `samtools_index`: To index aligned bam file.
* `samtools_flagstat`: To summarize alignment flags.
* `featureCounts`: To quantify gene abundances.
* `RSeQC`: Several steps included.\
	- `gtfToGenePred`: To convert GTF annotation to "genePred" format.
	- `genePredToBed`: To convert "genePred" annotation to "bed" format.
	- `r_distribution`: To summarize reads distribution over genome features.
	- `gCoverage`: To summarize read coverage over gene body.

The outputs and logs from alignment, quantification and QC steps are
collected together into the output folder. A final QC report could be
generated by `multiqc`, which is also available in the data package.

Here are the short summary and steps plot:
```{r}
short(rnaseq_Sf)
plotCWL(rnaseq_Sf)
```

### Prepare data
An RNASeq test data set can be downloaded from [genomedata](http://genomedata.org/rnaseq-tutorial/HBR_UHR_ERCC_ds_5pc.tar), which includes paired-end fastqs for 6 samples.
```{r, eval=FALSE}
download.file("http://genomedata.org/rnaseq-tutorial/HBR_UHR_ERCC_ds_5pc.tar", "apps/RNASeq/data/HBR_UHR_ERCC_ds_5pc.tar)
untar("apps/RNASeq/data/HBR_UHR_ERCC_ds_5pc.tar", exdir = "apps/RNASeq/data/")
```

The input data must be in a named list, with the same names as the input list of the pipeline. For this pipeline, 5 inputs are required to be set, including `in_seqfiles`, `in_prefix`, `in_genomeDir`, `in_GTFfile` and `in_runThreadN`.

There are two different input lists, `inputList` and `paramList`. The `inputList` is used to define the inputs for each sample and will be submitted to different cluster nodes. The `paramList` is used to define parameters which are shared in all jobs.

Two following inputs should be listed in `inputList`:

* `in_seqfiles`: A list with the fastq files of each sample in each element. The names of the list are also required to be defined and can be the sample IDs. The length of the list will be the same as the number of samples, thus the list will be defined to `inputList` and assigned to different nodes for parallel computing.

* `in_prefix` is the same as `in_seqfiles`, which defines a list of sample IDs.

```{r}
files <- normalizePath(list.files("apps/RNASeq/data/", ".gz", full.names = TRUE))
files <- tapply(files, substring(basename(files), 1, 8), as.list)
inputList <- list(in_seqfiles = files,
                  in_prefix = as.list(names(files)))
```

These 3 parameter will be defined in `paramList`:

* `in_genomeDir`: The reference genome indexes for STAR.

* `in_GTFfile`: The gene annotation file in GTF format.

* `in_runThreadN`: The number of threads to run for each job.

```{r}
paramList <- list(
    in_genomeDir = "apps/data/GRCh38_100/",
    in_GTFfile = "apps/data/gencode.v25.annotation.gtf",
    in_runThreadN = 4
)
```

In some cases, we need to modify the default arguments in some steps of a pipeline. For example,
```{r}
arguments(rnaseq_Sf, "STAR")[[2]] <- "2"
head(arguments(rnaseq_Sf, "STAR"))
```

### Submit pipeline with SGE
The function `runCWLBatch` is used to submit the pipeline to cluster server. In addition to defining `inputList` and `paramList`, we need to define parallel parameters from the `BiocParallel` package. Here is an example where we use "sge" to submit the jobs. The "sge" template is a bash script with some predefined parameters for "qsub". The nodes queue name and number of slots/threads are variables from the template and can be assigned by the `resources` list. 

```{r, eval=FALSE}
res <- runCWLBatch(cwl = rnaseq_Sf, outdir = "apps/RNASeq/output/",
                   inputList = inputList, paramList = paramList,
                   BPPARAM = BatchtoolsParam(
                       workers = lengths(inputList)[1], cluster = "sge",
                       template = "apps/data/sge_centos7.tmpl",
                       resources = list(queue = "centos7.q",
                                        threads = 4)))
```

That's it! The fastqc files of each sample will be submitted to different nodes to run the whole pipeline automatically.

All the results have been collected to output directory of each sample. For example,
```{r}
dir("apps/RNASeq/output/HBR_Rep1")
```

### QC Summary
The tool "multiqc" can aggregate results from the multiple outputs of the pipeline and generate a single page report, which also was implemented in the `RcwlPipelines` package:

```{r, eval=FALSE}
multiqc$dir <- "apps/RNASeq/output"
multiqc
```
We can also run the tool using `Rcwl` locally with the option `docker = TRUE`:

```{r, eval=FALSE}
runCWL(multiqc, stderr = "", Args = "--preserve-entire-environment", docker = FALSE)
```

### Abundances summary
The R/Bioconductor package `edgeR` can be used to calculate the RPKM and CPM abundances.
```{r}
countfiles <- list.files("apps/RNASeq/output", "out.featureCounts.txt$",
                         recursive = TRUE, full.names = TRUE)
samples <- basename(dirname(countfiles))

rExp <- function(countfile){
    count1 <- read.table(countfile, header = TRUE)[, c(1,6,7)]
    rpkm1 <- edgeR::rpkm(count1[,3,drop=F], gene.length = count1$Length)
    cpm1 <- edgeR::cpm(count1[,3])
    count1 <- data.frame(count1, rpkm1, cpm1)
    colnames(count1)[3:5] <- c("count", "rpkm", "cpm")
    return(count1)
}
```

```{r}
head(rExp(countfiles[1]))
```

```{r, eval=FALSE}
for(i in 1:length(samples)) {
    exp1 <- rExp(countfiles[i])
    write.table(exp1, file = paste0("apps/RNASeq/output/", samples[i],
                                    "/", samples[i], "_abundance.tsv"),
                row.names = FALSE, quote = FALSE, sep = "\t")
}
```

We can also easily wrap the R function to a `cwlParam` object.
```{r, eval=FALSE}
rExp <- function(countfile){
    count1 <- read.table(countfile, header = TRUE)[, c(1,6,7)]
    rpkm1 <- edgeR::rpkm(count1[,3,drop=F], gene.length = count1$Length)
    cpm1 <- edgeR::cpm(count1[,3])
    count1 <- data.frame(count1, rpkm1, cpm1)
    colnames(count1)[3:5] <- c("count", "rpkm", "cpm")
    write.table(exp1, file = paste0(tools::file_path_sans_ext(basename(countfile)),
                                    "_abundance.tsv"),
                row.names = FALSE, quote = FALSE, sep = "\t")
}
p1 <- InputParam(id = "countfile", type = "File",
                 prefix = "countfile=", separate = FALSE)
o1 <- OutputParam(id = "exp", type = "File", glob = "*abundance.tsv")
rExpr <- cwlParam(baseCommand = rExp,
                  inputs = InputParamList(p1),
                  outputs = OutputParamList(o1))
```

```{r, eval=FALSE}
countfiles <- as.list(countfiles)
names(countfiles) <- samples
inputList <- list(countfile = countfiles)

res1 <- runCWLBatch(rExpr, outdir = "apps/RNASeq/output", inputList,
                    BPPARAM = BatchtoolsParam(workers = length(samples),
                                              cluster = "sge",
                                              template = "apps/data/sge.tmpl",
                                              resources = list(threads = 16,
                                                               queue = "all.q",
                                                               jobname = "Exp"),
                                              log = TRUE, logdir = ".", progressbar = TRUE),
                    stderr = "")
```


## transcriptome quantification
There are many tools available for transcriptome quantification, such as kallisto, StringTie, salmon, Trinity and so on.

### Kallisto
The kallisto is a tool for quantifying abundances of transcripts with raw fastq reads and indexed reference transcriptomes. The `kallisto_index` is used to build an index file from reference transcriptome fasta.
```{r, eval=FALSE}
kallisto_index$fasta <- "apps/data/gencode.v25.transcripts.fa"
kallisto_index$index <- "gencode.v25.transcripts_kallisto"
runCWL(kallisto_index, outdir = "apps/data/", stderr = "")
```

The `kallisto_quant` runs the quantification algorithm to estimate the transcripts expression abundances.
```{r, eval=FALSE}
inputList <- list(fastq = files)
paramList <- list(index = "apps/data/gencode.v25.transcripts_kallisto",
                  threads = 16)

res2 <- runCWLBatch(kallisto_quant, outdir = "apps/RNASeq/output", inputList, paramList,
                    BPPARAM = BatchtoolsParam(workers = length(samples),
                                              cluster = "sge",
                                              template = "apps/data/sge.tmpl",
                                              resources = list(threads = 16,
                                                               queue = "all.q",
                                                               jobname = "kallisto"),
                                              log = TRUE, logdir = ".", progressbar = TRUE),
                    stderr = "")
```

Here are the results:
```{r}
list.files("apps/RNASeq/output/HBR_Rep1", "abundance")
```

## single cell RNAseq

## miRNA

The `miRDeep2` is one of the popular tools for discovering known and novel miRNAs from small RNA sequencing data. We wrapped the mapping and quantification steps into `miRDeep2PL`. Here is the instructions for `miRDeep2`: <https://github.com/rajewsky-lab/mirdeep2>.

```{r}
plotCWL(miRDeep2PL)
```

We use the data from `mirdeep2` github repository as an example.
<https://github.com/rajewsky-lab/mirdeep2/tree/master/tutorial_dir>

```{r}
list.files("apps/miRNA/tutorial_dir")
```

### Prepare reference
First, we need to build indexes for the miRNA reference with `bowtie-build`. This is only required to be performed once for each refernce genome.
```{r, eval=FALSE}
bowtie_build$ref <- "apps/miRNA/tutorial_dir/cel_cluster.fa"
bowtie_build$outPrefix <- "cel_cluster"
idxRes <- runCWL(bowtie_build, outdir = "apps/miRNA/output/genome", stderr = "")
file.copy("apps/miRNA/tutorial_dir/cel_cluster.fa", "apps/miRNA/output/genome/cel_cluster.fa")
```

Here are the indexed reference files.
```{r}
dir_info("apps/miRNA/output/genome") %>% select(path, size)
```

### Run miRDeep2 pipeline
First we need to prepare the inputs into 'inputList' and 'paramList' for parallel execution.
```{r}
inputs(miRDeep2PL)
```

To mimic multiple samples analysis, here we just repeat to use the input reads.
```{r}
reads <- list(sample1 = "apps/miRNA/tutorial_dir/reads.fa",
              sample2 = "apps/miRNA/tutorial_dir/reads.fa")

inputList <- list(reads = reads)
paramList <- list(adapter = "TCGTATGCCGTCTTCTGCTTGT",
                  genome = "apps/miRNA/output/genome/cel_cluster.fa",
                  miRef = "apps/miRNA/tutorial_dir/mature_ref_this_species.fa",
                  miOther = "apps/miRNA/tutorial_dir/mature_ref_other_species.fa",
                  precursors = "apps/miRNA/tutorial_dir/precursors_ref_this_species.fa",
                  species = "C.elegans")
```

Let's run the pipeline with two computing nodes.
```{r, eval=FALSE}
mirRes <- runCWLBatch(miRDeep2PL, outdir = "apps/miRNA/output/", inputList, paramList,
                      BPPARAM = BatchtoolsParam(workers = 2, cluster = "sge",
                                                template = "apps/data/sge.tmpl",
                                                resources = list(jobname = "miRNA",
                                                                 queue = "all.q",
                                                                 threads = 2),
                                                log=TRUE, logdir=".", progressbar = T),
                      stderr = "")

```

Here are the results:
```{r}
dir_info("apps/miRNA/output/sample1") %>% select(path, size)
```
